# -*- coding: utf-8 -*-
"""A2_GenerativeModels.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wD5lsZCSwuHsmCBELLJ5-M5QUxO8dIoq

# Introduction to Deep Learning, Assignment 2, Task 1

<div style="text-align: right">   </div>

In this notebook we are going to cover two generative models for generating novel images:

1. Variational Autoencoders (**VAEs**)
2. Generative adversarial networks (**GANs**)


<img src="https://lilianweng.github.io/lil-log/assets/images/three-generative-models.png" width="500">


Your main goal will be to retrain these models on a dataset of your choice and do some experiments on the learned latent space.

When using the Lab Computers, download the Jupyter Notebook to one of the machines first.

If you want to use Google Colab, you should first copy this notebook and enable GPU runtime in 'Runtime -> Change runtime type -> Hardware acceleration -> GPU **OR** TPU'.
"""

### If you are running on LIACS Lab machines, run the command below to reproduce the same package environment as Colab

#!pip install tf_keras==2.17.0 # Uncomment this to set up the right version

import os
os.environ['TF_USE_LEGACY_KERAS'] = '1'

from tqdm import tqdm
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt

#from google.colab import drive
# drive.mount('/content/drive', force_remount=True) ## If you want to use your google drive

#!wget https://surfdrive.surf.nl/s/wxStiBetTKDJC32/download -O face_dataset_64x64.npy

"""
### Dataset

This dataset is called [Flickr-Faces-HQ Dataset](https://github.com/NVlabs/ffhq-dataset). Here we will use a downsampled version of it (64x64x3) that will speed up all the experiments. [Download](https://surfdrive.surf.nl/s/wxStiBetTKDJC32).

After downloading you should copy it to your google drive's main directory (or modify the code to load it from elsewhere).

After running the notebook on this default dataset you then need to find a dataset of your own."""





import os
import cv2
import numpy as np

def load_real_samples(image_dir, scale=False, img_size=64, limit=20000):
    """
    Loads JPG images from a directory, converts to numpy array, 
    resizes to img_size × img_size, and optionally scales.
    """

    images = []
    count = 0

    for filename in os.listdir(image_dir):
        if filename.lower().endswith(('.jpg', '.jpeg', '.png')):
            path = os.path.join(image_dir, filename)
            img = cv2.imread(path)

            if img is None:
                continue  # skip unreadable images

            # convert BGR → RGB
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

            # resize to 64×64
            img = cv2.resize(img, (img_size, img_size))

            images.append(img)
            count += 1

            if count >= limit:
                break

    X = np.array(images, dtype=np.float32)

    # Apply your original scaling logic
    if scale:
        X = (X - 127.5) * 2

    return X / 255.0

# We will use this function to display the output of our models throughout this notebook
def grid_plot(images, latent_dim, filters,epoch='', name='', n=3, save=False, scale=False,model_name="vae"):
    if scale:
        images = (images + 1) / 2.0
    for index in range(n * n):
        plt.subplot(n, n, 1 + index)
        plt.axis('off')
        plt.imshow(images[index])
    fig = plt.gcf()
    fig.suptitle(name + '  '+ str(epoch), fontsize=14)
    if save:
        filename = f"results/{model_name}/latent{latent_dim}_filters{filters}_epoch{epoch+1}.png"
        plt.savefig(filename)
        plt.close()
    


dataset = load_real_samples("/data/s4561341/cats/")

"""## 2.1. Introduction

The generative models that we are going to cover both have the following components:

1. A downsampling architecture (encoder in case of VAE, and discriminator in case of GAN) to either extract features from the data or model its distribution.
2. An upsampling architecture (decoder for VAE, generator for GAN) that will use some kind of latent vector to generate new samples that resemble the data that it was trained on.

Since we are going to be dealing with images, we are going to use convolutional networks for upsampling and downsampling, similar to what you see below.

<img src="https://i2.wp.com/sefiks.com/wp-content/uploads/2018/03/convolutional-autoencoder.png" width="500">


#### Code for building these components:
"""

from tensorflow.keras.layers import Dense, Flatten, Conv2D, Conv2DTranspose, Reshape

def build_conv_net(in_shape, out_shape, n_downsampling_layers=4, filters=128, out_activation='sigmoid'):
    """
    Build a basic convolutional network
    """
    default_args=dict(kernel_size=(3,3), strides=(2,2), padding='same', activation='relu')

    input = tf.keras.Input(shape=in_shape)
    x = Conv2D(filters=filters, name='enc_input', **default_args)(input)

    for _ in range(n_downsampling_layers):
        x = Conv2D(**default_args, filters=filters)(x)

    x = Flatten()(x)
    x = Dense(out_shape, activation=out_activation, name='enc_output')(x)

    model = tf.keras.Model(inputs=input, outputs=x, name='Encoder')

    model.summary()
    return model


def build_deconv_net(latent_dim, n_upsampling_layers=4, filters=128, activation_out='sigmoid'):
    """
    Build a deconvolutional network for decoding/upscaling latent vectors

    When building the deconvolutional architecture, usually it is best to use the same layer sizes that
    were used in the downsampling network and the Conv2DTranspose layers are used instead of Conv2D layers.
    Using identical layers and hyperparameters ensures that the dimensionality of our output matches the
    shape of our input images.
    """
    input = tf.keras.Input(shape=(latent_dim,))
    x = Dense(4 * 4 * 64, input_dim=latent_dim, name='dec_input')(input)
    x = Reshape((4, 4, 64))(x) # This matches the output size of the downsampling architecture

    default_args=dict(kernel_size=(3,3), strides=(2,2), padding='same', activation='relu')

    for i in range(n_upsampling_layers):
        x = Conv2DTranspose(filters=filters, **default_args)(x)

    # This last convolutional layer converts back to 3 channel RGB image
    x = Conv2D(filters=3, kernel_size=(3,3), padding='same', activation=activation_out, name='dec_output')(x)

    model = tf.keras.Model(inputs=input, outputs=x, name='Decoder')
    model.summary()
    return model

"""### Convolutional Autoencoder example

Using these two basic building blocks we can now build a Convolutional Autoencoder (CAE).

<img src="https://lilianweng.github.io/lil-log/assets/images/autoencoder-architecture.png" width="500">



Even though it's not a generative model, CAE is a great way to illustrate how these two components (convolutional and deconvolutional networks) can be used together to reconstruct images.

You can view such model as a compression/dimensionality reduction method as each image gets compressed to a vector of 256 numbers by the encoder and gets decompressed back into an image using the decoder network.
"""

def build_convolutional_autoencoder(data_shape, latent_dim, filters=128):
    encoder = build_conv_net(in_shape=data_shape, out_shape=latent_dim, filters=filters)
    decoder = build_deconv_net(latent_dim, activation_out='sigmoid', filters=filters)

    # We connect encoder and decoder into a single model
    autoencoder = tf.keras.Sequential([encoder, decoder])

    # Binary crossentropy loss - pairwise comparison between input and output pixels
    autoencoder.compile(loss='binary_crossentropy', optimizer='adam')

    return autoencoder


# Defining the model dimensions and building it
image_size = dataset.shape[1:]


class Sampling(tf.keras.layers.Layer):
    """
    Custom layer for the variational autoencoder
    It takes two vectors as input - one for means and other for variances of the latent variables described by a multimodal gaussian
    Its output is a latent vector randomly sampled from this distribution
    """
    def call(self, inputs):
        z_mean, z_var = inputs
        batch = tf.shape(z_mean)[0]
        dim = tf.shape(z_mean)[1]
        epsilon = tf.keras.backend.random_normal(shape=(batch, dim))
        return z_mean + tf.exp(0.5 * z_var) * epsilon

def build_vae(data_shape, latent_dim, filters=128):

    # Building the encoder - starts with a simple downsampling convolutional network
    encoder = build_conv_net(data_shape, latent_dim*2, filters=filters)

    # Adding special sampling layer that uses the reparametrization trick
    z_mean = Dense(latent_dim)(encoder.output)
    z_var = Dense(latent_dim)(encoder.output)
    z = Sampling()([z_mean, z_var])

    # Connecting the two encoder parts
    encoder = tf.keras.Model(inputs=encoder.input, outputs=z)

    # Defining the decoder which is a regular upsampling deconvolutional network
    decoder = build_deconv_net(latent_dim, activation_out='sigmoid', filters=filters)
    vae = tf.keras.Model(inputs=encoder.input, outputs=decoder(z))

    # Define a custom layer for the KL loss calculation
    class KLLossLayer(tf.keras.layers.Layer):
        def call(self, inputs):
            z_mean, z_var = inputs
            kl_loss = -0.5 * tf.reduce_sum(z_var - tf.square(z_mean) - tf.exp(z_var) + 1)
            # Add the KL loss to the model's losses
            self.add_loss(kl_loss / tf.cast(tf.keras.backend.prod(data_shape), tf.float32))
            return inputs  # Pass through the inputs unchanged

    # Apply the custom layer to z_mean and z_var
    _, _ = KLLossLayer()([z_mean, z_var])

    vae.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=1e-3), loss='binary_crossentropy')

    return encoder, decoder, vae

# Training the VAE model
# Training the VAE model

latent_dims = [64, 128]
filters = [128, 256]

# Ensure directory exists for saving plots
os.makedirs('results/vae', exist_ok=True)

for latent_dim in latent_dims:
    for filter_count in filters: # Renamed 'filter' to 'filter_count' to avoid shadowing python keyword
        print(f"Training VAE with Latent Dim: {latent_dim}, Filters: {filter_count}")
        
        encoder, decoder, vae = build_vae(dataset.shape[1:], latent_dim=latent_dim, filters=filter_count)
        
        # Initialize a list to store loss values for this specific model configuration
        loss_history = []
        
        for epoch in range(100):
            # Capture the training history
            history = vae.fit(x=dataset, y=dataset, epochs=1, batch_size=8, verbose=1)
            
            # Append the loss from this epoch to the history list
            # history.history['loss'] returns a list, we take the first item since epochs=1
            loss_history.append(history.history['loss'][0])

            # Generate random vectors that we will use to sample from the learned latent space
            coefficient = 6                               
            latent_vectors = np.random.randn(9, latent_dim) 
            images = decoder(latent_vectors / coefficient) 
            
            # Save grid plots (only saving every 10 epochs to save disk space/time, optional change)
            if epoch == 99:
                grid_plot(images, latent_dim, filter_count, epoch, name=f'VAE Generated (Latent:{latent_dim} Filter:{filter_count})', n=3, save=True, model_name="vae")
            
            # Interpolation experiment at specific epoch
            if epoch == 19:
                point_a = np.random.randn(1, latent_dim)
                point_b = np.random.randn(1, latent_dim)
                point_interp = (point_a + point_b) / 2.0
                latent_batch = np.vstack([point_a, point_interp, point_b])
                generated_images = decoder(latent_batch / coefficient)
                
                plt.figure(figsize=(12, 4))
                titles = ["Random Point A", "Interpolation (A+B)/2", "Random Point B"]

                for i in range(3):
                    plt.subplot(1, 3, i + 1)
                    plt.imshow(generated_images[i])
                    plt.title(titles[i])
                    plt.axis('off')

                plt.savefig(f'results/vae/vae_interpolation_latent{latent_dim}_filter{filter_count}.png')
                plt.close()

        # --- NEW CODE: PLOT LOSS CURVE ---
        plt.figure(figsize=(10, 6))
        plt.plot(loss_history, label='Training Loss')
        plt.title(f'VAE Training Loss\nLatent Dim: {latent_dim}, Filters: {filter_count}')
        plt.xlabel('Epochs')
        plt.ylabel('Loss (Binary Crossentropy + KL)')
        plt.legend()
        plt.grid(True)
        
        # Save the loss plot
        loss_plot_filename = f'results/vae/loss_plot_latent{latent_dim}_filter{filter_count}.png'
        plt.savefig(loss_plot_filename)
        plt.close() # Close figure to free memory
        print(f"Loss plot saved to {loss_plot_filename}")